<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  





  
  <title>Santosh Kumar Radha | Perovskite to Pseudospin - A Julia challenge</title>
  <meta name="description" content="Personal webpage
">
  <!-- Google Analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-142155886-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-142155886-1');
</script>
<!-- /Google Analytics -->

  

  <link rel="shortcut icon" href="http://localhost:4000/assets/img/favicon.ico">

  <link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
  <link rel="canonical" href="http://localhost:4000/blog/2020/julia-MC/">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    
    <span class="site-title">
        
        <a href="http://localhost:4000/"><strong>Santosh</strong> Radha</a>
    </span>
    

    <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>
      <div class="trigger">
        <!-- About -->
        <a class="page-link" href="http://localhost:4000/">About</a>

        <!-- Blog -->
        <a class="page-link" href="http://localhost:4000/blog/">Blog</a>

        <!-- Pages -->
        
          
            
          
        
          
            
          
        
          
            
          
        
          
        
          
            
          
        
          
            
          
        
          
        
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
            <a class="page-link" href="http://localhost:4000/research/">Research</a>
            
            
          
        
          
            
            <a class="page-link" href="http://localhost:4000/publications/">Publications</a>
            
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
        
          
        
          
        



        <!-- github -->
        <a class="page-link" href="https://github.com/santoshkumarradha">Github</a>
        <!-- flicker -->
        <!-- <a class="page-link" href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=2ahUKEwj3sIP5grzdAhWmq1kKHX9zCA0QFjAAegQIBxAB&url=https%3A%2F%2Fwww.flickr.com%2Fphotos%2Fsantyphotography%2F&usg=AOvVaw3wIh929JJSpXgNa3DHo7cb">Photography</a> -->
        <!-- design -->
        <!-- <a class="page-link" href="https://www.behance.net/instrumentsantosh">Design</a> -->
        <!-- CV link -->
        <!-- <a class="page-link" href="http://localhost:4000/assets/pdf/CV.pdf">vitae</a> -->

      </div>
    </nav>

  </div>

</header>



    <div class="page-content">
      <div class="wrapper">
        <script type="text/x-mathjax-config">
var font = "Neo-Euler";
MathJax.Hub.Config({
	tex2jax: {
		inlineMath: [['$','$']],
		displayMath: [['\\[','\\]']],
		processEscapes: true,
	},
	"SVG":{ 
		font:font
	},
	"HTML-CSS": {
		webFont: font,
		imageFont: font,
		preferredFont: font,
		availableFonts: [],
		scale: 85,
		mtextFontInherit: true
	}
}); </script> 

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,https://idcrook.github.io/assets/js/MathJaxLocal.js"></script>
<div class="post">

  <header class="post-header">
    <h8 class="post-title">Perovskite to Pseudospin - A Julia challenge</h8>
        <p class="post-meta">May 13, 2020</p>
        <p class="post-meta">
      <span>tags: 
    
      
      <a href="/tag/Julia"><code class="highligher-rouge"><nobr>Julia</nobr></code>&nbsp;</a>
    
      
      <a href="/tag/Monte-carlo"><code class="highligher-rouge"><nobr>Monte-carlo</nobr></code>&nbsp;</a>
    
      
      <a href="/tag/perovskite"><code class="highligher-rouge"><nobr>perovskite</nobr></code>&nbsp;</a>
    
      
      <a href="/tag/physics"><code class="highligher-rouge"><nobr>physics</nobr></code>&nbsp;</a>
    
      
      <a href="/tag/coding"><code class="highligher-rouge"><nobr>coding</nobr></code>&nbsp;</a>
    
  </span></p>

  </header>
  


  <article class="post-content">
    <p>After a conference hosted by AFOSR (Air Force Office of Science and Research), I met with an interesting bloke who introduced me to this new language called Julia, that is as fast as FORTRAN/C and yet quick and easy to prototype as Python. Though it was tempting, I brushed off that idea that it could be really worthwhile trying until I met with a snag in one of my research projects.</p>

<h3 id="short-introduction-to-the-perovskite-problem">Short Introduction to the Perovskite Problem</h3>

<p>Here’s the deal, we had this very intriguing idea that in Hallide perovskites, the structures can be mapped to a pseudo classical spin vector. Details of which are published in <a href="https://arxiv.org/abs/1909.07495">this article</a> <a href="#1">[1]</a>. To give a gist, Hallide perovskites are systems that have the formula $ABX_3$ where the $B$ atom is surrounded by 6 $X$ atoms giving it a local octahedral symmetry. In the article we showed that the system undergoes a ferroelectric transition which pushes the central atom $B$ towards body diagonal reducing the local symmetry from “octahedral” to “tetrahedral” forming $BX_3$ tetrahedron units. Here’s the picture of that</p>

<p align="center">
  <img width="200px" min-width="200px" src="/assets/img/offcenter.jpg" />
</p>

<p>This is taken from yet another <a href="https://journals.aps.org/prmaterials/abstract/10.1103/PhysRevMaterials.2.063605">old paper</a> <a href="#2">[2]</a> where we showed why and how this happens. The resulting effect of this is that the singular units of tetrahedrons, now contain a cloud of electron density that sticks at the tail giving the tetrahedral unit a net dipole charge point in the $(1,1,1)$ body diagonal direction. In the next <a href="https://arxiv.org/abs/1909.07495">paper</a> <a href="#1">[1]</a>, we came up with a clever way of relating this structure to another polymorph structure that is in monoclinic structure. We realized that the mono-clinic structure is actually the same system with the tetrahedrons pointing in opposite direction as shown bellow. Thus if one considers the orientation of the tetraehedron/dipole as a classical pseudo spin vector in real space, the Ferromagnetic arrangement of the system is the perovskite structure while the Antiferromagenetic arrangement is the monoclinic. And it turns out that along with the electric dipole interaction, the system also can stabilize itself by <em>delocalizing</em> its electrons by being in a octahedral environment where one has more periodic chains of atoms, thus reducing the potential energy (or) another way to understand this is to see that being in octahedral environment allows for more “bond” formation and thus reduces the total energy of the system ( we will cover a separate blog post of why bond formation reduces the energy)</p>

<p align="center">
  <img width="300px" min-width="200px" src="/assets/img/TOC.png" />
</p>

<p>This way of looking at these two structures gives very important insights to their stability and why they are shaped the way they are. The perovskite form of this system is a very promising candidate for Solar cell with one of the highest efficiency, but the problem being it degrades to form other structures. If one could understand what stabilizes the crystal in the given structure, we could in principle control the degradation. Secondly, because of the difference in band gap of the monoclinic and perovskite system, If one could transition back and forth between them, one could have a opaque material to a transparent material that is a solar cell. This might be possible say with electric field as the pseudo spins are nothing but dipoles in space.</p>

<p>Okay, so having said all these, the goal for future <em>(read current)</em> work was to predict if such transitions could be realized and if so, how much of an electric field or Temperature difference does one need to do that. A viable approach for this would be to write down the spin Hamiltonian and derive a susuptablity tensor. The Hamiltonian for this system when one considers only a <em>up</em> and <em>down</em> orientation of the pseudo spins turns out to be</p>

<script type="math/tex; mode=display">\begin{equation}
H=H_{d i p o l e}+ \mathcal{g} \cdot H_{b o n d}
\end{equation}\label{eq:1}</script>

<script type="math/tex; mode=display">H_{d i p o l e}=J_{\|} \sum_{\langle i j\rangle} S_{i \|} S_{j \|}+J_{\perp} \sum_{\langle i j\rangle} \mathbf{S}_{i \perp} \cdot \mathbf{S}_{j \perp}</script>

<script type="math/tex; mode=display">H_{b o n d}=-U \sum_{\langle i j\rangle} \Theta\left(S_{i \|} S_{j \|}\right)</script>

<p>Where $\mathcal{g}$ is the coupling constant. This some-what brutal expression can still be solved and shown to have the perovskite and monoclinic as ground state solution based on the sign of $\mathcal{g}$. For a generic spin orientation, it turns out that $H_{d i p o l e}$ remains almost the same ( its just the dipole-dipole classical interaction ) but $H_{b o n d}$ is more sophisticated that a  fairly in-adept theorist like myself is unable to decipher. So we turn out to approximating it and making it tractable. On close inspection, it seems natural that the <em>bond</em> formation of the central atom $B$ can be approximated to linear order to the number of nearest $X$. This is brilliant, because we can now numerically compute $H_{b o n d}$ as $\sum^6_{i}r_i$ where $r_i$ is the nearest neighbor distance (NND) to the 6 $X$ atoms surrounding $B$ for different orientation of $BX_3$ tetrahedrons. Thus we now have all the ingredients for solving the complete Hamiltonian which is given by</p>

<script type="math/tex; mode=display">\begin{equation}H(\theta_1,\phi_1,\theta_2,\phi_2)=V_x (S^x_i\cdot S^x_j)+V_y(S^y_i\cdot  S^y_j)+V_z(S^z_i\cdot  S^z_j)+\mathcal{g} \cdot U(\theta_1,\phi_1,\theta_2,\phi_2)\end{equation}\label{eq:2}</script>

<p>where</p>

<script type="math/tex; mode=display">V_x(\Theta_1,\Theta_2)=\alpha(\theta_1,\phi_1,\theta_2,\phi_2)-3sin(\theta_1)cos(\phi_1)sin(\theta_2)cos(\phi_2)</script>

<script type="math/tex; mode=display">V_y(\Theta_1,\Theta_3)=\alpha(\theta_1,\phi_1,\theta_2,\phi_2)-3sin(\theta_1)sin(\phi_1)sin(\theta_2)sin(\phi_2)</script>

<script type="math/tex; mode=display">V_z(\Theta_1,\Theta_4)=\alpha(\theta_1,\phi_1,\theta_2,\phi_2)-3cos(\theta_1)cos(\theta_2)</script>

<p>and $U(\theta_1,\phi_1,\theta_2,\phi_2)$ is known numerically. We now can solve \ref{eq:2} using Monte-carlo technique where we sample new orientation of the spins and calculate the NND for estimating $U$ and analytically solve $H_{d i p}$ and proceed to next step. This also helps us couple electric field to the calculation as it is, but another term added that couple spins of particular direction ! But the snag here is that NND algorithms are computational expensive. For instance the in python, the most efficient one written using <code class="language-plaintext highlighter-rouge">cython</code> costs around .09 sec for single calculation of a $5x5x5$ super cell. And this is where Julia comes in, speeding things up.</p>

<h3 id="getting-hands-dirty-with-julia">Getting hands dirty with Julia</h3>

<p>I am going to outline a quick prototype of the code to calculate the total energy I wrote in Julia (remember this might still be amateur as I have been playing around with Julia just for a week and thought this QMC project might be a good introduction).</p>

<p>We start by importing the required packages, we also use the pymatgen module in python created by MaterialsProject to easily read and import structure data.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">LinearAlgebra</span>
<span class="k">using</span> <span class="n">StaticArrays</span>
<span class="k">using</span> <span class="n">PyCall</span>
<span class="k">using</span> <span class="n">Plots</span>
<span class="k">using</span> <span class="n">Distances</span>
<span class="k">using</span> <span class="n">Statistics</span>
<span class="n">theme</span><span class="x">(</span><span class="o">:</span><span class="n">dark</span><span class="x">)</span>
<span class="k">using</span> <span class="n">PlotlyJS</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pyimport</span><span class="x">(</span><span class="s">"pymatgen"</span><span class="x">)</span>
</code></pre></div></div>

<p>The idea behind Julia is to define types just like in case of C which then is stored as custom data types at machine level which utilizes the full power of low level types likle Int64 and Float64. For us, we create a type called tetra which holds the positions of the 3 $X$ atoms (which is Cl in this example) and 1 $B$ atom (which is Ge)</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span><span class="nc"> tetra</span>
    <span class="n">ge</span><span class="o">::</span><span class="kt">Array</span><span class="x">{</span><span class="kt">Float64</span><span class="x">,</span><span class="mi">1</span><span class="x">}</span>
    <span class="n">cl1</span><span class="o">::</span><span class="kt">Array</span><span class="x">{</span><span class="kt">Float64</span><span class="x">,</span><span class="mi">1</span><span class="x">}</span>
    <span class="n">cl2</span><span class="o">::</span><span class="kt">Array</span><span class="x">{</span><span class="kt">Float64</span><span class="x">,</span><span class="mi">1</span><span class="x">}</span>
    <span class="n">cl3</span><span class="o">::</span><span class="kt">Array</span><span class="x">{</span><span class="kt">Float64</span><span class="x">,</span><span class="mi">1</span><span class="x">}</span>
<span class="k">end</span> 
</code></pre></div></div>

<p>We then write a function that takes a set of 3D coordinate and rotates it in 3D space that is anchored at <code class="language-plaintext highlighter-rouge">anc</code> by an angle <code class="language-plaintext highlighter-rouge">theta</code> with respect to <code class="language-plaintext highlighter-rouge">axis</code>. For a given tetrahedron, we will rotate it with respect to the center of mass of the tetrahedron which is $\sum_{i=1}^4 \frac{r_i}{4}$ of the tetrahedron vertex.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">icross</span><span class="x">(</span><span class="n">b</span><span class="x">)</span> <span class="o">=</span> <span class="n">copy</span><span class="x">(</span><span class="kt">Transpose</span><span class="x">(</span><span class="n">hcat</span><span class="x">([</span><span class="n">cross</span><span class="x">(</span><span class="kt">Matrix</span><span class="x">(</span><span class="mf">1.0</span><span class="n">I</span><span class="x">,</span> <span class="mi">3</span><span class="x">,</span> <span class="mi">3</span><span class="x">)[</span><span class="o">:</span><span class="x">,</span><span class="n">i</span><span class="x">],</span><span class="n">b</span><span class="x">)</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="x">]</span><span class="o">...</span><span class="x">)));</span>
<span class="n">anchor</span><span class="x">(</span><span class="n">tetra</span><span class="x">)</span> <span class="o">=</span> <span class="x">(</span><span class="n">tetra</span><span class="o">.</span><span class="n">ge</span><span class="o">+</span><span class="n">tetra</span><span class="o">.</span><span class="n">cl1</span><span class="o">+</span><span class="n">tetra</span><span class="o">.</span><span class="n">cl2</span><span class="o">+</span><span class="n">tetra</span><span class="o">.</span><span class="n">cl3</span><span class="x">)</span><span class="o">/</span><span class="mi">4</span>
<span class="k">function</span><span class="nf"> Mdot</span><span class="x">(</span><span class="n">a1</span><span class="x">,</span><span class="n">a2</span><span class="x">)</span>
    <span class="cm">#=redefing dot product like numpy for matrix=#</span>
    <span class="n">a1_1</span><span class="o">=</span><span class="n">copy</span><span class="x">(</span><span class="kt">Transpose</span><span class="x">(</span><span class="n">a1</span><span class="x">))</span><span class="err">'</span>
    <span class="k">return</span> <span class="x">[</span><span class="n">dot</span><span class="x">(</span><span class="n">a1_1</span><span class="x">[</span><span class="n">i</span><span class="x">,</span><span class="o">:</span><span class="x">],</span><span class="n">a2</span><span class="x">)</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="x">]</span>
<span class="k">end</span>
<span class="k">function</span><span class="nf"> rot</span><span class="x">(</span><span class="n">coords</span><span class="x">,</span><span class="n">anc</span><span class="x">,</span><span class="n">axis</span><span class="x">,</span><span class="n">theta</span><span class="x">)</span>
    <span class="cm">#=rotate coords by theta wrt anc with axis as axis=#</span>
    <span class="n">theta</span> <span class="o">%=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">pi</span>
    <span class="n">rm</span><span class="o">=</span><span class="n">exp</span><span class="x">(</span><span class="n">icross</span><span class="x">(</span><span class="n">axis</span><span class="o">/</span><span class="n">norm</span><span class="x">(</span><span class="n">axis</span><span class="x">))</span><span class="o">*</span><span class="n">theta</span><span class="x">)</span>
    <span class="n">val</span><span class="o">=</span><span class="n">Mdot</span><span class="x">(</span><span class="n">rm</span><span class="x">,(</span><span class="n">coords</span><span class="o">-</span><span class="n">anc</span><span class="x">))</span><span class="o">+</span><span class="n">anc</span>
    <span class="k">return</span> <span class="n">val</span>
    <span class="k">end</span><span class="x">;</span>

<span class="k">function</span><span class="nf"> rot_tetra_test_1</span><span class="x">(</span><span class="n">t</span><span class="o">::</span><span class="n">tetra</span><span class="x">,</span><span class="n">axis</span><span class="o">::</span><span class="kt">Array</span><span class="x">{</span><span class="kt">Float64</span><span class="x">,</span><span class="mi">1</span><span class="x">},</span><span class="n">theta</span><span class="x">)</span>
    <span class="cm">#=rotate all atoms in tetra by theta with axis = axis=#</span>
    <span class="n">anc</span><span class="o">=</span><span class="n">anchor</span><span class="x">(</span><span class="n">t</span><span class="x">)</span>
    <span class="n">ge</span><span class="o">=</span><span class="n">rot</span><span class="x">(</span><span class="n">t</span><span class="o">.</span><span class="n">ge</span><span class="x">,</span><span class="n">anc</span><span class="x">,</span><span class="n">axis</span><span class="x">,</span><span class="n">theta</span><span class="x">)</span>
    <span class="n">cl1</span><span class="o">=</span><span class="n">rot</span><span class="x">(</span><span class="n">t</span><span class="o">.</span><span class="n">cl1</span><span class="x">,</span><span class="n">anc</span><span class="x">,</span><span class="n">axis</span><span class="x">,</span><span class="n">theta</span><span class="x">)</span>
    <span class="n">cl2</span><span class="o">=</span><span class="n">rot</span><span class="x">(</span><span class="n">t</span><span class="o">.</span><span class="n">cl2</span><span class="x">,</span><span class="n">anc</span><span class="x">,</span><span class="n">axis</span><span class="x">,</span><span class="n">theta</span><span class="x">)</span>
    <span class="n">cl3</span><span class="o">=</span><span class="n">rot</span><span class="x">(</span><span class="n">t</span><span class="o">.</span><span class="n">cl3</span><span class="x">,</span><span class="n">anc</span><span class="x">,</span><span class="n">axis</span><span class="x">,</span><span class="n">theta</span><span class="x">)</span>
    <span class="k">return</span> <span class="n">tetra</span><span class="x">(</span><span class="n">ge</span><span class="x">,</span><span class="n">cl1</span><span class="x">,</span><span class="n">cl2</span><span class="x">,</span><span class="n">cl3</span><span class="x">)</span>
    <span class="k">end</span><span class="x">;</span>
</code></pre></div></div>

<p>Finally function <code class="language-plaintext highlighter-rouge">rot_tetra_test_1</code> takes the tetra structure and rotates it by given <code class="language-plaintext highlighter-rouge">theta</code> along <code class="language-plaintext highlighter-rouge">axis</code>. Note that unlike python, we here define the type of each variable. This is strictly not needed, but is often a good habit to follow as it helps speed up computation times at times and certainly helps debugging. To test the speed at which this works, we create a $5x5x5$ system and rotate every tetrahedron</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@time</span> <span class="k">begin</span>
<span class="n">n</span><span class="o">=</span><span class="mi">5</span>
<span class="n">system</span><span class="o">=</span><span class="kt">Array</span><span class="x">{</span><span class="n">tetra</span><span class="x">,</span><span class="mi">3</span><span class="x">}(</span><span class="nb">undef</span><span class="x">,</span><span class="n">n</span><span class="x">,</span><span class="n">n</span><span class="x">,</span><span class="n">n</span><span class="x">);</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">length</span><span class="x">(</span><span class="n">system</span><span class="x">)</span>
    <span class="n">system</span><span class="x">[</span><span class="n">i</span><span class="x">]</span><span class="o">=</span><span class="n">tetra</span><span class="x">(</span><span class="n">randn</span><span class="x">(</span><span class="mi">3</span><span class="x">),</span><span class="n">randn</span><span class="x">(</span><span class="mi">3</span><span class="x">),</span><span class="n">randn</span><span class="x">(</span><span class="mi">3</span><span class="x">),</span><span class="n">randn</span><span class="x">(</span><span class="mi">3</span><span class="x">))</span>
    <span class="k">end</span><span class="x">;</span>

<span class="n">axis</span><span class="o">=</span><span class="x">[</span><span class="mi">0</span><span class="x">,</span><span class="mi">1</span><span class="x">,</span><span class="mf">1.</span><span class="x">]</span>
<span class="n">theta</span><span class="o">=</span><span class="nb">pi</span><span class="o">/</span><span class="mi">2</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">length</span><span class="x">(</span><span class="n">system</span><span class="x">)</span>
    <span class="n">system</span><span class="x">[</span><span class="n">i</span><span class="x">]</span><span class="o">=</span><span class="n">rot_tetra_test_1</span><span class="x">(</span><span class="n">system</span><span class="x">[</span><span class="n">i</span><span class="x">],</span><span class="n">axis</span><span class="x">,</span><span class="n">theta</span><span class="x">)</span>
	<span class="k">end</span><span class="x">;</span>
<span class="k">end</span>
</code></pre></div></div>

<p>we get the following output</p>

<div class="codebox bspace">
2.834009 seconds (9.24 M allocations: 439.714 MiB, 5.91% gc time)
</div>
<p>Wait what ! 2.8 seconds for just rotating ? Well, this is so because the first run involves compiling all the functions and structures and hence the down time. Running it again, we see that it actually is</p>

<div class="codebox bspace">
0.005242 seconds (25.26 k allocations: 2.771 MiB)
</div>
<p>which is the reason we now use julia. The speed of computing 125 flips amounts to around $5\mu s$ adding a bunch of over head for other calculation, this would amount to around $20000$ flips a second. Which is indeed a nice count. All this in my Macbook Pro ‘18. Running in a cluster, this would complete a full MC calculation in an hour or so.</p>

<p>Now the heavy lifting comes for calculating the NN distance, forfeiting the complex algorithm, we will look at the nearest cell of tetra in all 3 directions and create a distance matrix between the central $B$ atom and all $X$ atoms from nearest cells. To do this, comes the interesting part, what should we do about the edge atoms? well we impose periodic boundary conditions and study the system as function of $n$ (system size) and hope that it converges w.r.t to that.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> get_nn_1</span><span class="x">(</span><span class="n">system</span><span class="x">,</span><span class="n">pos</span><span class="x">,</span><span class="n">size</span><span class="x">)</span>
    <span class="cm">#= Get first 6 Nearest neibghors to Ge atoms 
    which are Chlorine with PBC=#</span>
    <span class="n">a</span><span class="o">=</span><span class="x">(</span><span class="o">-</span><span class="n">system</span><span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">1</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span><span class="o">.</span><span class="n">ge</span><span class="o">+</span><span class="n">system</span><span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">1</span><span class="x">,</span><span class="mi">2</span><span class="x">]</span><span class="o">.</span><span class="n">ge</span><span class="x">)[</span><span class="mi">3</span><span class="x">]</span>
    <span class="k">function</span><span class="nf"> pbc</span><span class="x">(</span><span class="n">i</span><span class="x">,</span><span class="n">n</span><span class="x">)</span> 
        <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">n</span>
            <span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="n">n</span><span class="x">,</span><span class="n">a</span><span class="o">*</span><span class="n">size</span>
        <span class="k">elseif</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">0</span>
            <span class="k">return</span> <span class="n">n</span><span class="x">,</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="x">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="x">)</span>
        <span class="k">else</span> 
            <span class="k">return</span> <span class="n">i</span><span class="x">,</span><span class="mi">0</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">tmp</span><span class="o">=</span><span class="kt">Array</span><span class="x">{</span><span class="kt">Float64</span><span class="x">,</span> <span class="mi">1</span><span class="x">}[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span>
                <span class="n">i1</span><span class="x">,</span><span class="n">ai</span><span class="o">=</span><span class="n">pbc</span><span class="x">(</span><span class="n">pos</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span><span class="o">+</span><span class="n">i</span><span class="x">,</span><span class="n">size</span><span class="x">)</span>
                <span class="n">j1</span><span class="x">,</span><span class="n">aj</span><span class="o">=</span><span class="n">pbc</span><span class="x">(</span><span class="n">pos</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span><span class="o">+</span><span class="n">j</span><span class="x">,</span><span class="n">size</span><span class="x">)</span>
                <span class="n">k1</span><span class="x">,</span><span class="n">ak</span><span class="o">=</span><span class="n">pbc</span><span class="x">(</span><span class="n">pos</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span><span class="o">+</span><span class="n">k</span><span class="x">,</span><span class="n">size</span><span class="x">)</span>
                <span class="n">push!</span><span class="x">(</span><span class="n">tmp</span><span class="x">,</span><span class="n">system</span><span class="x">[</span><span class="n">i1</span><span class="x">,</span><span class="n">j1</span><span class="x">,</span><span class="n">k1</span><span class="x">]</span><span class="o">.</span><span class="n">cl1</span><span class="o">+</span><span class="x">[</span><span class="n">ai</span><span class="x">,</span><span class="n">aj</span><span class="x">,</span><span class="n">ak</span><span class="x">])</span>
                <span class="n">push!</span><span class="x">(</span><span class="n">tmp</span><span class="x">,</span><span class="n">system</span><span class="x">[</span><span class="n">i1</span><span class="x">,</span><span class="n">j1</span><span class="x">,</span><span class="n">k1</span><span class="x">]</span><span class="o">.</span><span class="n">cl2</span><span class="o">+</span><span class="x">[</span><span class="n">ai</span><span class="x">,</span><span class="n">aj</span><span class="x">,</span><span class="n">ak</span><span class="x">])</span>
                <span class="n">push!</span><span class="x">(</span><span class="n">tmp</span><span class="x">,</span><span class="n">system</span><span class="x">[</span><span class="n">i1</span><span class="x">,</span><span class="n">j1</span><span class="x">,</span><span class="n">k1</span><span class="x">]</span><span class="o">.</span><span class="n">cl3</span><span class="o">+</span><span class="x">[</span><span class="n">ai</span><span class="x">,</span><span class="n">aj</span><span class="x">,</span><span class="n">ak</span><span class="x">])</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">tmp</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Finally, we get calculate $U$ by calculating the distance and taking either the <em>mean</em> or <em>variance</em> of the closest 6 NN $X$ atoms</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> get_mean_var</span><span class="x">(</span><span class="n">system</span><span class="x">,</span><span class="n">pos</span><span class="x">,</span><span class="n">return_type</span><span class="o">=</span><span class="s">"var"</span><span class="x">)</span>
    <span class="cm">#= Get the mean or variance of a 
    position of lattice  wrt bond distance=#</span>
    <span class="n">sys</span><span class="o">=</span><span class="n">system</span><span class="x">[</span><span class="n">pos</span><span class="x">[</span><span class="mi">1</span><span class="x">],</span><span class="n">pos</span><span class="x">[</span><span class="mi">2</span><span class="x">],</span><span class="n">pos</span><span class="x">[</span><span class="mi">3</span><span class="x">]]</span>
    <span class="n">distance_1</span><span class="o">=</span><span class="n">colwise</span><span class="x">(</span><span class="n">Euclidean</span><span class="x">(),</span> <span class="n">sys</span><span class="o">.</span><span class="n">ge</span><span class="x">,</span> <span class="n">copy</span><span class="x">(</span><span class="n">hcat</span><span class="x">(</span><span class="n">get_nn_1</span><span class="x">(</span><span class="n">system</span><span class="x">,</span><span class="n">pos</span><span class="x">,</span><span class="n">n</span><span class="x">)</span><span class="o">...</span><span class="x">)))</span>
    <span class="n">nn</span><span class="o">=</span><span class="n">sort</span><span class="x">(</span><span class="n">distance_1</span><span class="x">)[</span><span class="mi">1</span><span class="o">:</span><span class="mi">6</span><span class="x">]</span>
    <span class="n">var_sys</span><span class="o">=</span><span class="n">var</span><span class="x">(</span><span class="n">nn</span><span class="x">)</span>
    <span class="n">mean_sys</span><span class="o">=</span><span class="n">mean</span><span class="x">(</span><span class="n">nn</span><span class="x">)</span>
    <span class="k">if</span> <span class="n">return_type</span><span class="o">==</span><span class="s">"mean"</span>
        <span class="k">return</span> <span class="n">mean_sys</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">var_sys</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>To test it out, lets first load up the system, which is a 3D matrix holding tetra structure with real numbers from a perovskite system CsSiI$_2$ using pymatgen (Yes you can import python modules in Julia ! yay !)</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">function</span><span class="nf"> make_symstem</span><span class="x">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="x">)</span>
    <span class="n">cssii2</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">Structure</span><span class="o">.</span><span class="n">from_file</span><span class="x">(</span><span class="s">"Cssii2.cif"</span><span class="x">)</span>
    <span class="n">struc1</span><span class="o">=</span><span class="n">cssii2</span><span class="o">.</span><span class="n">copy</span><span class="x">()</span>
    <span class="n">struc1</span><span class="o">.</span><span class="n">make_supercell</span><span class="x">([[</span><span class="n">n</span><span class="x">,</span><span class="mi">0</span><span class="x">,</span><span class="mi">0</span><span class="x">],[</span><span class="mi">0</span><span class="x">,</span><span class="n">n</span><span class="x">,</span><span class="mi">0</span><span class="x">],[</span><span class="mi">0</span><span class="x">,</span><span class="mi">0</span><span class="x">,</span><span class="n">n</span><span class="x">]])</span>
    <span class="n">dist</span><span class="o">=</span><span class="n">cssii2</span><span class="o">.</span><span class="n">get_distance</span><span class="x">(</span><span class="mi">1</span><span class="x">,</span><span class="mi">3</span><span class="x">)</span><span class="o">+.</span><span class="mi">1</span>
    <span class="n">positions</span><span class="o">=</span><span class="kt">Array</span><span class="x">{</span><span class="kt">Int64</span><span class="x">,</span> <span class="mi">1</span><span class="x">}[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">struc1</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">species_string</span><span class="o">==</span><span class="s">"Si"</span>
            <span class="n">push!</span><span class="x">(</span><span class="n">positions</span><span class="x">,</span><span class="n">struc1</span><span class="o">.</span><span class="n">get_neighbor_list</span><span class="x">(</span><span class="n">dist</span><span class="x">,[</span><span class="n">i</span><span class="x">])[</span><span class="mi">2</span><span class="x">])</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">system</span><span class="o">=</span><span class="kt">Array</span><span class="x">{</span><span class="n">tetra</span><span class="x">,</span><span class="mi">3</span><span class="x">}(</span><span class="nb">undef</span><span class="x">,</span><span class="n">n</span><span class="x">,</span><span class="n">n</span><span class="x">,</span><span class="n">n</span><span class="x">);</span>
    <span class="n">cnt</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
            <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
                <span class="n">ge</span><span class="o">=</span><span class="n">get</span><span class="x">(</span><span class="n">struc1</span><span class="x">,</span><span class="n">reverse</span><span class="x">(</span><span class="n">positions</span><span class="x">[</span><span class="n">cnt</span><span class="x">])[</span><span class="mi">1</span><span class="x">])</span><span class="o">.</span><span class="n">coords</span>
                <span class="n">cl1</span><span class="o">=</span><span class="n">get</span><span class="x">(</span><span class="n">struc1</span><span class="x">,</span><span class="n">reverse</span><span class="x">(</span><span class="n">positions</span><span class="x">[</span><span class="n">cnt</span><span class="x">])[</span><span class="mi">2</span><span class="x">])</span><span class="o">.</span><span class="n">coords</span>
                <span class="n">cl2</span><span class="o">=</span><span class="n">get</span><span class="x">(</span><span class="n">struc1</span><span class="x">,</span><span class="n">reverse</span><span class="x">(</span><span class="n">positions</span><span class="x">[</span><span class="n">cnt</span><span class="x">])[</span><span class="mi">3</span><span class="x">])</span><span class="o">.</span><span class="n">coords</span>
                <span class="n">cl3</span><span class="o">=</span><span class="n">get</span><span class="x">(</span><span class="n">struc1</span><span class="x">,</span><span class="n">reverse</span><span class="x">(</span><span class="n">positions</span><span class="x">[</span><span class="n">cnt</span><span class="x">])[</span><span class="mi">4</span><span class="x">])</span><span class="o">.</span><span class="n">coords</span>
                <span class="n">system</span><span class="x">[</span><span class="n">i</span><span class="x">,</span><span class="n">j</span><span class="x">,</span><span class="n">k</span><span class="x">]</span><span class="o">=</span><span class="n">tetra</span><span class="x">(</span><span class="n">ge</span><span class="x">,</span><span class="n">cl1</span><span class="x">,</span><span class="n">cl2</span><span class="x">,</span><span class="n">cl3</span><span class="x">)</span>    
                <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">system</span>
<span class="k">end</span>

<span class="n">n</span><span class="o">=</span><span class="mi">4</span>
<span class="n">system</span><span class="o">=</span><span class="n">make_symstem</span><span class="x">(</span><span class="n">n</span><span class="x">);</span>
</code></pre></div></div>

<p>Then we take a single tetrahedron at the $(4,4,2)$ site and then rotate it along $\theta=(1,1,1)$ and $\phi=(1,0,0)$ axis in small steps from $(0,2\pi)$ and then plot $U(\theta,\phi)$</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="o">=</span><span class="x">[]</span>
<span class="n">nk</span><span class="o">=</span><span class="mi">100</span>
<span class="nd">@time</span> <span class="k">begin</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="kt">LinRange</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="nb">pi</span><span class="o">*</span><span class="mi">2</span><span class="x">,</span> <span class="n">nk</span><span class="x">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="kt">LinRange</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="nb">pi</span><span class="o">*</span><span class="mi">2</span><span class="x">,</span> <span class="n">nk</span><span class="x">)</span>
			<span class="n">theta</span><span class="o">=</span><span class="n">i</span>
			<span class="n">axis</span><span class="o">=</span><span class="x">[</span><span class="mi">2</span><span class="x">,</span><span class="mi">2</span><span class="x">,</span><span class="mf">2.</span><span class="x">]</span>
			<span class="n">system_test</span><span class="o">=</span><span class="n">copy</span><span class="x">(</span><span class="n">system</span><span class="x">)</span>
			<span class="n">pos_1</span><span class="o">=</span><span class="x">[</span><span class="mi">4</span><span class="x">,</span><span class="mi">4</span><span class="x">,</span><span class="mi">2</span><span class="x">]</span>
			<span class="n">system_test</span><span class="x">[</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">1</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">3</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">3</span><span class="x">]]</span><span class="o">=</span>
			        <span class="n">rot_tetra_test_1</span><span class="x">(</span><span class="n">system</span><span class="x">[</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">1</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">3</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">3</span><span class="x">]],</span><span class="n">axis</span><span class="x">,</span><span class="n">theta</span><span class="x">);</span>
			<span class="n">theta</span><span class="o">=</span><span class="n">j</span>
			<span class="n">axis</span><span class="o">=</span><span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">0</span><span class="x">,</span><span class="mf">0.</span><span class="x">]</span>
			<span class="n">system_test</span><span class="x">[</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">1</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">3</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">3</span><span class="x">]]</span><span class="o">=</span>
			        <span class="n">rot_tetra_test_1</span><span class="x">(</span><span class="n">system_test</span><span class="x">[</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">1</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">3</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">3</span><span class="x">]],</span><span class="n">axis</span><span class="x">,</span><span class="n">theta</span><span class="x">);</span>
			            
			<span class="n">mean_1</span><span class="o">=</span><span class="n">mean</span><span class="x">([</span><span class="n">get_mean_var</span><span class="x">(</span><span class="n">system_test</span><span class="x">,[</span><span class="n">i</span><span class="x">,</span><span class="n">j</span><span class="x">,</span><span class="n">k</span><span class="x">],</span><span class="s">"var"</span><span class="x">)</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span> <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span> <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="x">])</span>
			<span class="n">push!</span><span class="x">(</span><span class="n">a</span><span class="x">,</span><span class="n">mean_1</span><span class="x">)</span>
			<span class="k">end</span>
<span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<p>This entire $100x100=10^4$ calculations took $4s$ to run. We can plot it using</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="o">=</span><span class="n">reshape</span><span class="x">(</span><span class="n">a</span><span class="x">,</span><span class="n">nk</span><span class="x">,</span><span class="n">nk</span><span class="x">)</span>
<span class="n">contourf</span><span class="x">(</span><span class="kt">LinRange</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="nb">pi</span><span class="o">*</span><span class="mi">2</span><span class="x">,</span> <span class="n">nk</span><span class="x">),</span>
    <span class="kt">LinRange</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="nb">pi</span><span class="o">*</span><span class="mi">2</span><span class="x">,</span> <span class="n">nk</span><span class="x">),</span> <span class="n">a</span><span class="x">,</span><span class="n">levels</span><span class="o">=</span><span class="mi">10</span><span class="x">,</span><span class="n">aspect_ratio</span> <span class="o">=</span> <span class="mi">1</span><span class="x">)</span>
</code></pre></div></div>
<p>which gives us</p>

<p align="center">
  <img width="400px" min-width="200px" src="/assets/img/U.png" />
</p>

<p>We can see that at $\thea=\phi=0$ the minimum U occurs which is the lowest energy and the system has a nice periodicity. Well this verifies at least to some level that the code is working.</p>

<p>Now finally before we leave, lets do a final check to see that the system is indeed what it is and periodicity and rotation is maintained. For this, we plot the tetrahedrons (or their projection) along the $x-y$ axis and randomly rotate each units by random angle along $(0,0,1)$ axis ($z$-axis). We will plot their periodic counter part in different color just to make sure that rotating an edge atom has effect on the other side because of periodic boundary condition. We do that by</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">system_test</span><span class="o">=</span><span class="n">copy</span><span class="x">(</span><span class="n">system</span><span class="x">)</span>
<span class="k">function</span><span class="nf"> plot_perov</span><span class="x">()</span>
    <span class="n">plt</span><span class="o">=</span><span class="n">plot</span><span class="x">(</span><span class="mi">5</span><span class="x">,</span><span class="n">xlim</span><span class="o">=</span><span class="x">(</span><span class="o">-</span><span class="mi">6</span><span class="x">,</span><span class="mi">33</span><span class="x">),</span><span class="n">ylim</span><span class="o">=</span><span class="x">(</span><span class="o">-</span><span class="mi">6</span><span class="x">,</span><span class="mi">33</span><span class="x">),</span> <span class="n">aspect_ratio</span><span class="o">=</span><span class="mi">1</span><span class="x">,</span><span class="n">legend</span><span class="o">=</span><span class="nb">false</span><span class="x">,</span><span class="n">size</span> <span class="o">=</span> <span class="x">(</span><span class="mi">800</span><span class="x">,</span> <span class="mi">800</span><span class="x">))</span>
    <span class="kd">global</span> <span class="n">system_test</span>
    <span class="n">pos_1</span><span class="o">=</span><span class="x">[</span><span class="n">rand</span><span class="x">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">4</span><span class="x">),</span><span class="n">rand</span><span class="x">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">4</span><span class="x">),</span><span class="mi">1</span><span class="x">]</span>
    <span class="n">axis</span><span class="o">=</span><span class="x">[</span><span class="mi">0</span><span class="x">,</span><span class="mi">0</span><span class="x">,</span><span class="mf">1.</span><span class="x">]</span>
    <span class="n">theta</span><span class="o">=</span><span class="nb">pi</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">rand</span><span class="x">()</span>
    <span class="n">system_test</span><span class="x">[</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">1</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">2</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">3</span><span class="x">]]</span><span class="o">=</span>
            <span class="n">rot_tetra_test_1</span><span class="x">(</span><span class="n">system</span><span class="x">[</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">1</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">2</span><span class="x">],</span><span class="n">pos_1</span><span class="x">[</span><span class="mi">3</span><span class="x">]],</span><span class="n">axis</span><span class="x">,</span><span class="n">theta</span><span class="x">);</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">0</span><span class="o">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">a</span><span class="o">=</span><span class="x">(</span><span class="o">-</span><span class="n">system</span><span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">1</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span><span class="o">.</span><span class="n">ge</span><span class="o">+</span><span class="n">system</span><span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">1</span><span class="x">,</span><span class="mi">2</span><span class="x">]</span><span class="o">.</span><span class="n">ge</span><span class="x">)[</span><span class="mi">3</span><span class="x">]</span>
        <span class="k">function</span><span class="nf"> pbc</span><span class="x">(</span><span class="n">i</span><span class="x">,</span><span class="n">n</span><span class="x">)</span> 
            <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">n</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="n">n</span><span class="x">,</span><span class="n">a</span><span class="o">*</span><span class="n">n</span>
            <span class="k">elseif</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">0</span>
                <span class="k">return</span> <span class="n">n</span><span class="x">,</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="x">(</span><span class="n">n</span><span class="x">)</span>
            <span class="k">else</span> 
                <span class="k">return</span> <span class="n">i</span><span class="x">,</span><span class="mi">0</span>
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="n">i1</span><span class="x">,</span><span class="n">ai</span><span class="o">=</span><span class="n">pbc</span><span class="x">(</span><span class="n">i</span><span class="x">,</span><span class="n">n</span><span class="x">)</span>
        <span class="n">j1</span><span class="x">,</span><span class="n">aj</span><span class="o">=</span><span class="n">pbc</span><span class="x">(</span><span class="n">j</span><span class="x">,</span><span class="n">n</span><span class="x">)</span>
    <span class="n">x</span><span class="o">=</span><span class="x">[]</span>
    <span class="n">y</span><span class="o">=</span><span class="x">[]</span>
    <span class="k">if</span> <span class="n">ai!</span><span class="o">=</span><span class="mi">0</span> <span class="o">||</span> <span class="n">aj</span> <span class="o">!=</span><span class="mi">0</span>
            <span class="n">col</span><span class="o">=</span><span class="s">"yellow"</span><span class="x">;</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span>
    <span class="k">else</span> 
            <span class="n">col</span><span class="o">=</span><span class="s">"red"</span><span class="x">;</span><span class="n">alpha</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">end</span>
    <span class="n">x</span><span class="o">=</span><span class="x">[</span><span class="n">system_test</span><span class="x">[</span><span class="n">i1</span><span class="x">,</span><span class="n">j1</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span><span class="o">.</span><span class="n">ge</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span><span class="o">+</span><span class="n">ai</span>
            <span class="x">,</span><span class="n">system_test</span><span class="x">[</span><span class="n">i1</span><span class="x">,</span><span class="n">j1</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span><span class="o">.</span><span class="n">cl1</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span><span class="o">+</span><span class="n">ai</span>
            <span class="x">,</span><span class="n">system_test</span><span class="x">[</span><span class="n">i1</span><span class="x">,</span><span class="n">j1</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span><span class="o">.</span><span class="n">cl2</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span><span class="o">+</span><span class="n">ai</span>
            <span class="x">,</span><span class="n">system_test</span><span class="x">[</span><span class="n">i1</span><span class="x">,</span><span class="n">j1</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span><span class="o">.</span><span class="n">ge</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span><span class="o">+</span><span class="n">ai</span><span class="x">]</span>
        
    <span class="n">y</span><span class="o">=</span><span class="x">[</span><span class="n">system_test</span><span class="x">[</span><span class="n">i1</span><span class="x">,</span><span class="n">j1</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span><span class="o">.</span><span class="n">ge</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span><span class="o">+</span><span class="n">aj</span>
            <span class="x">,</span><span class="n">system_test</span><span class="x">[</span><span class="n">i1</span><span class="x">,</span><span class="n">j1</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span><span class="o">.</span><span class="n">cl1</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span><span class="o">+</span><span class="n">aj</span>
            <span class="x">,</span><span class="n">system_test</span><span class="x">[</span><span class="n">i1</span><span class="x">,</span><span class="n">j1</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span><span class="o">.</span><span class="n">cl2</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span><span class="o">+</span><span class="n">aj</span>
            <span class="x">,</span><span class="n">system_test</span><span class="x">[</span><span class="n">i1</span><span class="x">,</span><span class="n">j1</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span><span class="o">.</span><span class="n">ge</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span><span class="o">+</span><span class="n">aj</span><span class="x">]</span>
    <span class="n">plt</span><span class="o">=</span><span class="n">plot!</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">y</span><span class="x">,</span><span class="n">color</span><span class="o">=</span><span class="s">"grey"</span><span class="x">,</span><span class="n">label</span><span class="o">=</span><span class="s">""</span><span class="x">)</span>
    <span class="n">plot!</span><span class="x">(</span><span class="n">Plots</span><span class="o">.</span><span class="n">Shape</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">y</span><span class="x">),</span><span class="n">label</span><span class="o">=</span><span class="s">""</span><span class="x">,</span><span class="n">color</span><span class="o">=</span><span class="n">col</span><span class="x">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="x">)</span>
    <span class="n">scatter!</span><span class="x">(</span><span class="n">plt</span><span class="x">,</span><span class="n">x</span><span class="x">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">3</span><span class="x">],</span><span class="n">y</span><span class="x">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">3</span><span class="x">],</span><span class="n">color</span><span class="o">=</span><span class="s">"red"</span><span class="x">,</span><span class="n">label</span><span class="o">=</span><span class="s">""</span><span class="x">)</span>
    <span class="n">scatter!</span><span class="x">(</span><span class="n">plt</span><span class="x">,[</span><span class="n">x</span><span class="x">[</span><span class="mi">1</span><span class="x">]],[</span><span class="n">y</span><span class="x">[</span><span class="mi">1</span><span class="x">]],</span><span class="n">color</span><span class="o">=</span><span class="s">"green"</span><span class="x">,</span><span class="n">label</span><span class="o">=</span><span class="s">""</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<p>This plots a very beautiful Movie that gives us this</p>

<p align="center">
  <img width="400px" min-width="200px" src="/assets/img/peorvsk2.gif" />
</p>

<p>It is easy to see that a change in edge tetrahedrons (or their projected triangle) has an effect on the opposite boundary triangle denoted by yellow atom.</p>

<p>Not bad for a quick 2 day foray into Julia. Will update as soon as I add more modules. Ciao.</p>

<hr />

<h4 id="references">References</h4>
<div class="footcite">
<a id="1">[1]</a> 
Radha, Santosh Kumar, and Walter R. L. Lambrecht. “Understanding the Crystallographic Phase Relations in Alkali‐Trihalogeno‐Germanates in Terms of Ferroelectric or Antiferroelectric Arrangements of the Tetrahedral GeX$_3$ Units.” Advanced Electronic Materials 6.2 (2019): 1900887. Crossref. Web.
</div>
<div class="footcite">
<a id="2">[2]</a> 
Radha, Santosh Kumar, Churna Bhandari, and Walter RL Lambrecht. "Distortion modes in halide perovskites: To twist or to stretch, a matter of tolerance and lone pairs." Physical Review Materials 2.6 (2018): 063605.
</div>

  </article>

  

</div>
<p></p>
<div class="lineHorizontal__container">
  <div class="lineHorizontal"></div>
</div>


 <h2>Topics to explore</h2>



  
  
  <a href="/tag/physics"><code class="highligher-rouge"><nobr>physics</nobr></code></a>

  
  
  <a href="/tag/coding"><code class="highligher-rouge"><nobr>coding</nobr></code></a>

  
  
  <a href="/tag/python"><code class="highligher-rouge"><nobr>python</nobr></code></a>

  
  
  <a href="/tag/perovskite"><code class="highligher-rouge"><nobr>perovskite</nobr></code></a>

  
  
  <a href="/tag/numba"><code class="highligher-rouge"><nobr>numba</nobr></code></a>

  
  
  <a href="/tag/Monte-carlo"><code class="highligher-rouge"><nobr>Monte-carlo</nobr></code></a>

  
  
  <a href="/tag/Julia"><code class="highligher-rouge"><nobr>Julia</nobr></code></a>

  
  
  <a href="/tag/topology"><code class="highligher-rouge"><nobr>topology</nobr></code></a>

  
  
  <a href="/tag/tight-binding"><code class="highligher-rouge"><nobr>tight-binding</nobr></code></a>

  
  
  <a href="/tag/susceptibility"><code class="highligher-rouge"><nobr>susceptibility</nobr></code></a>

  
  
  <a href="/tag/spin-waves"><code class="highligher-rouge"><nobr>spin-waves</nobr></code></a>

  
  
  <a href="/tag/quantum"><code class="highligher-rouge"><nobr>quantum</nobr></code></a>

  
  
  <a href="/tag/pysktb"><code class="highligher-rouge"><nobr>pysktb</nobr></code></a>

  
  
  <a href="/tag/optimization"><code class="highligher-rouge"><nobr>optimization</nobr></code></a>

  
  
  <a href="/tag/finance"><code class="highligher-rouge"><nobr>finance</nobr></code></a>

  
  
  <a href="/tag/Slaster-koster"><code class="highligher-rouge"><nobr>Slaster-koster</nobr></code></a>

      </div>
    </div>

    <footer>

  <div class="wrapper">
    &copy; Copyright 2020 Santosh Kumar Radha.
    
    
  </div>

</footer>


    <!-- Load jQuery -->
<script src="//code.jquery.com/jquery-1.12.4.min.js"></script>

<!-- Load Common JS -->
<script src="http://localhost:4000/assets/js/common.js"></script>


<!-- Load KaTeX -->
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js"></script>
<script src="http://localhost:4000/assets/js/katex.js"></script>




<!-- Include custom icon fonts -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/fontawesome-all.min.css">
<link rel="stylesheet" href="http://localhost:4000/assets/css/academicons.min.css">




  </body>

</html>
